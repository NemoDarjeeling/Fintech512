### A Philosophy of Software Design | John Ousterhout | Talks at Google
**Notes:** Problem decomposition; get criticism, learn, and iterate...; minimize complexity; strategic (produce a great design; do small steps 10%-20% slower than you would have for unittest, documentation...) vs. tactical (get something working, "tactical tornadoes"); classes should be deep (small interface, rich function; method should be small and more classes better?; UNIX I/O!); errors defined out of existence (more exceptions better code?; redefine semantics - no exception!, just make the normal behaviour do the right thing; don't introduce exceptions for users to do the right thing);  
**Summary:** John Ousterhout's talk "A Philosophy of Software Design" at Talks at Google presents a set of principles and guidelines to help developers write better software. He emphasizes the importance of simplicity, separation of concerns, and consistent use of good abstractions. He provides examples and case studies to illustrate his principles and warns against common pitfalls of software design.  
### Paper Prototyping: The 10-Minute Practical Guide
**Notes:**  
Use printer paper and cheap pencils/pens.  
Start with a warm-up!  
Prototype mobile-first or progressive enhancement.  
Stick to one sketch per screen (a piece of paper).   
Iterate as the ideas come to mind.   
Planning is crucial for a successful paper prototyping session!   
### Paper prototyping is a waste of time
**Notes:**  
Paper prototypes generate false positives.  
Get reactions, not feedback.  
Paper prototypes don’t save time.  
High fidelity is a little harder and a whole lot better.  
### Extra Work: Chapter 4, The Pragmatic Programmer: your journey to mastery, 20th Anniversary Edition, 2nd Edition  
**Excerpts:**  
You Can't Write Perfect Software;  
Design with Contracts;  
Crash Early;  
Use Assertions to Prevent the Impossible;  
Finish What You Start;  
Act Locally;  
Take Small Steps—Always;  
Avoid Fortune-Telling;  
**Summary:** This chapter stresses the importance of being paranoid in programming by anticipating and handling potential problems. It recommends thorough testing, defensive programming, redundancy, and security measures to ensure code reliability. By being proactive, programmers can create more robust systems.
