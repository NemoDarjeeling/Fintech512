# Your paper and video summaries go here.

# Rubric:
* Write a short summary of the paper/video, as follows:
* First line: Paper Title, citation source
* Keywords: List keywords from paper, or select 4-8 most relevant terms from the paper
* First paragraph: describe the main points of the paper/video.
* Second paragraph: Present the paper/video's strengths and weaknesses from your point of view.

Title: No Silver Bullet: Essence and Accident in Software Engineering; Source: https://sakai.duke.edu/access/content/group/FINTECH-512-02-Sp22/Papers/Brooks-NoSilverBullet.pdf
Keywords: accidental activities; essential parts; complexity, conformity, changeability, invisibility; breakthroughs solving accidental difficulties; promising attacks on conceptual essence
Summary: Brooks approaches the difficulties in software engineering by dividing them into essential and accidental, then he argued due to the intrinsic characteristics of software, which are complexity, conformity, changeability, invisibility, there is no panecea to solve essential problems, and pointed out many of our past breakthroughs were aimed at accidental difficulties rather than essential ones, such as high-level language, time-sharing and unified programming environments. Then, writer examined current plausible "hope for the silver", including Ada, OOP, AI, expert systems, "automatic" programming, graphic programming, program verification, environments and tools, and workstations, and revealed that they are either targeting at accidental problems or too vague. However, writer did presented several promising attacks on essence problems from a conceptual and empirical rather than technical perspective, for instance, buy than build, requirements refinement and rapid prototyping, incremental development (grow), and great designers. 
Opinions: The author insightfully divides the problems encountered in software engineering into essential and unexpected difficulties according to Aristotle's philosophical viewpoint, and accordingly divides the way to deal with them into “fashioning” and “constructing”. The author insightfully points out that many of our problem-solving approaches at this stage are actually technical in nature, and are therefore mostly constructing, so what can be solved is only unexpected difficulties; in fact, due to the fundamental nature of software, purely technical solutions cannot deal with its essential difficulties. This is undoubtedly a reflection on the optimism of technology-only, that as long as the fundamental characteristics of software and the endogenous defects of those who use it remain unchanged, no amount of technological advancement can deal with the essential problems faced in software development and usage. To solve these essential difficulties, we can only rely on humanistic approaches, such as more artistic trade-offs, more organic planning, and more emphasis on the active role of great designers in them. This approach is very practical and also offers new insights into the way people and technology can coexist. However, we have to point out that the authors may be too pessimistic about the speed of technological progress and its impact on productivity: the rapid progress in computing and transmission speed can greatly compress the "transaction costs" in software development and use, and when the computing speed is fast enough, even if the essential problems are not solved, people will not necessarily be troubled in their daily use of software. Moreover, this paper seems to focus too much on productivity, i.e., how much output the software gets per unit of input cost, but perhaps we can look at it the other way around, i.e., if we focus on quality, productivity will follow.

//2.5 hours for this 

Title: Implementing VisiCalc; Source: https://rmf.vc/ImplementingVisiCalc
Keywords: VisiCalc; a product, not a program; spreadsheet; simple, useful and user-friendly layout of the screen; keyboard usage and interacting; files, input and output; calculations and formulas; programming decisions; memory and patching; tools and environment
Summary: This is a story about how the writer and his colleagues implemented VisiCalc starting in 1978. With all of them having experience in programming and software design, they based the product on the Apple II with the designing principle of a simple but useful product, though they have to do reverse engineering to avoid Apple's licensing. The layout of the screen was incredibly user-friendly and allows users' intuitive manipulation. VisiCalc also enables interaction with keyboard. It solves the problem of overtyping or running ahead, used two arrow keys and the space bar to toggle between vertical and horizontal motion, and set command key. They also tried to make VisiCalc able to handle files and I/O, but dropped copy protection eventually. Moreover, they wrote function in VisiCalc, and used reverse polish notation to do precedence in the formulas. Programming Decisions related to this product emphasized strongly on efficiency and readability. They also made some improvements in memory & patching and tools & environment for this product before it was shipped.   
Opinion: This article on VisiCalc describes in great detail the origin of the idea, the iterations, and the final product of this killer app, especially since it was written by the inventor himself, so we can get a clearer picture of his goals and objectives in creating VisiCalc at that time: a product, not a program. But perhaps the inclusion of user feedback, follow-up requests, and subsequent improvements to the product by the inventor will make this article more complete and give us a better understanding of the qualities that make a successful piece of software. As for VisiCalc itself, it "represented a new idea of a way to use a computer and a new way of thinking about the world", which "allows the user to just solve the problem using familiar tools and concepts". The problem of the product might be the company was slow to upgrade the software, which resulted in it losing most of its market share later.

//2 hours for this 

Title: 'The History (and Future) of Software', Booch; Souce: https://www.youtube.com/watch?v=OdI7Ukf-Bf4
Keywords: 
Summary:
Opinion:


